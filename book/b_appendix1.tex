% The Clever Algorithms Project: http://www.CleverAlgorithms.com
% (c) Copyright 2010 Jason Brownlee. Some Rights Reserved. 
% This work is licensed under a Creative Commons Attribution-Noncommercial-Share Alike 2.5 Australia License.

% This is an appendix

\chapter{Getting Started in the Ruby Programming Language}
\label{ch:appendix1}

\section*{Overview}
This section provides a terse introduction into the Ruby programming language. It is intended for those who already have a grasp of another programming language (such as Java, C, C++, C\#, python, etc) to quickly get started with Ruby. This guide does not cover the whole Ruby language, rather it summarizes the basic keywords, constructs, and idioms of the language used in the code examples throughout the book.

% basics
\section*{Language Basics}
This section summarizes the basics of the language, including variables, flow control, data structures, and functions.

\subsection{Ruby Files}
Ruby is an interpreted language, meaning that programs are typed as text into a \texttt{.rb} file which is parsed and executed at the type the script is run. For example, the following example shows how to invoke the Ruby interpreter on a script in the file \texttt{genetic_algorithm.rb} from the command line:

\texttt{ruby genetic_algorithm.rb}

Ruby scripts are written in ASCII text and are parsed and executed in a linear manner (top to bottom). A script can define functionality (as modules, functions, and classes) and invoke functionality (such as calling a function). 

Comments in Ruby are defined by a \texttt{#} character, after which the remainder of the line is ignored. The only exception is in strings, where the character can have a special meaning.

The ruby interpreter can be used in an interactive manner by typing out a ruby script directly. This can be useful for testing specific behaviour. For example, it is incoraged that you open the ruby interpreter and follow along this guide by typing out the examples. the ruby interpreter can be opened from the command line by typing \texttt{irb} and exited again by typing \texttt{exit} from within the interpreter.

\subsection{Variables}
A variable holds a piece of information such as an integer, a scalar or a string.

a = 1    # a holds the integer value `1'
b = 2.2  # b holds the floating point value `2.2'
c = ``hello, world'' # c holds the string value `hello, world'

Ruby has a number of different data types (such as numbers and strings) although it does not enforce the type safety of variables. Instead it uses `duck typing', where as long as the value of a variable responds appropriately to messages it receives, the interpreter is happy.

Strings can be constructed from static text as well as the values of variables. The following example defines a variable and then defines a string with the variable. The \texttt{\#\{\}} is a special sequence that informs the interrupter to evaluate the contents of inside the brackets, in this case to evaluate the variable n, which happens to be assigned the value 55.

n = 55 # an integer 
s = ``The number is: #{n}''

The values of variables can be compared using the == for equality and != for inequality. The following provides an example of testing the equality of two variables and assigning the boolean (true or false) result to a third variable.

a = 1
b = 2
c = (a == b) # true

\subsection{Flow Control}
A script is a sequence of statements that invoke pre-defined functionality. There are structures for manipulating the flow of control within the script such as conditional statements and loops.

Conditional statements can take the traditional forms of \texttt{if} <condition> then <action>, with the standard variants of if then else and if then, else if. For example:

a == 1
b == 2
if(a == b) 
	a += 1 # equivalent to a = a + a
elsif a == 1 # brackets around conditions are optional
	a = 1
else 
 	a = 0
end

Conditional statements can also be added to the end of statements. For example a variable can be assigned a variable only if a condition holds, defined all on one line.

a = 2
b = 99 if a == 2

Loops allow a set of statements to be repeatedly executed \texttt{until} a condition is met or \texttt{while} a condition is not met

a = 0
while a < 10 # condition before the statements
	puts a += 1
end

b = 10
begin 
	puts b -= 1
end until b==0 # condition after the statements

As with the if conditions, the loops can be added to the end of statements allowing a loop on a single line.

a = 0
puts a += 1 while a<10

A block is a piece 

\subsection{Arrays and Hashs}
An array is a linear collection of variables and can be defined by creating a new \texttt{Array} object.

a = [] # define a new array implicitly
a = Array.new # explicilty create a new array
a = Array.new(10) # create a new array with space for 10 items
b = Array.new(10) {|i| i} # define a new array

\subsection{Functions}
The puts function can be used to write a line to the console.

puts(``Testing 1, 2, 3'')
puts ``Testing 4, 5, 6'' # note brackets are not required for the function call

Functions allow a program to be partitioned into discrete actions and pre-defined and reusable. The following is an example of a simple function

def test_function()
	puts ``Test!''
end

A function can take a list of variables called function arguments.

def test_function(a)
	puts ``Test: #{a}''
end

And a function can return a variable, called a return value.

def square(x)
	return x**2 # note the ** is a power-of operator in Ruby
end

% ways of doing stuf
\section*{Ruby Idioms}
todo

\subsection{Assignment}
todo

\subsection{Post-Conditions and Loops}
todo

\subsection{Looping Structures}
todo

\subsection{Printing to the Console}
todo


