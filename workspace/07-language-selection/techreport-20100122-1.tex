% Programming Language Selection for Introducing Unconventional Optimization Algorithms

% The Clever Algorithms Project: http://www.CleverAlgorithms.com
% (c) Copyright 2010 Jason Brownlee. Some Rights Reserved. 
% This work is licensed under a Creative Commons Attribution-Noncommercial-Share Alike 2.5 Australia License.

\documentclass[a4paper, 11pt]{article}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{url}
\usepackage[pdftex,breaklinks=true,colorlinks=true,urlcolor=blue,linkcolor=blue,citecolor=blue,]{hyperref}
\usepackage{geometry}
\usepackage[ruled, linesnumbered]{../algorithm2e}
\usepackage{listings} 
\usepackage{textcomp}
\usepackage{../upquote}
\input{../lua.def}

\lstset{basicstyle=\small,numbers=left,numberstyle=\tiny,frame=single,columns=flexible,upquote=true,showstringspaces=false,tabsize=2,captionpos=b,breaklines=true,breakatwhitespace=true}
\geometry{verbose,a4paper,tmargin=25mm,bmargin=25mm,lmargin=25mm,rmargin=25mm}

% Dear template user: fill these in
\newcommand{\myreporttitle}{Programming Language Selection for Optimization Algorithms}
% \newcommand{\myreportsubtitle}{}
\newcommand{\myreportauthor}{Jason Brownlee}
\newcommand{\myreportemail}{jasonb@CleverAlgorithms.com}
\newcommand{\myreportproject}{The Clever Algorithms Project\\\url{http://www.CleverAlgorithms.com}}
\newcommand{\myreportdate}{20100122}
\newcommand{\myreportfulldate}{January 22, 2010}
\newcommand{\myreportversion}{1}
\newcommand{\myreportlicense}{\copyright\ Copyright 2010 Jason Brownlee. Some Rights Reserved. This work is licensed under a Creative Commons Attribution-Noncommercial-Share Alike 2.5 Australia License.}

% leave this alone, it's templated baby!
% \title{{\myreporttitle}: {\myreportsubtitle}\footnote{\myreportlicense}}
\title{{\myreporttitle}\footnote{\myreportlicense}}
\author{\myreportauthor\\{\myreportemail}\\\small\myreportproject}
\date{\myreportfulldate\\{\small{Technical Report: CA-TR-{\myreportdate}-\myreportversion}}}
\begin{document}
\maketitle

% write a summary sentence for each major section
\section*{Abstract} 
todo

\begin{description}
	\item[Keywords:] {\small\texttt{Clever, Algorithms, Language, Selection, Optimization}}
\end{description} 

% summarise the document breakdown with cross references
\section{Introduction}
\label{sec:introduction}
% project
The Clever Algorithms project aims to describe a large number of optimization algorithms from the fields of Computational Intelligence, Natural Computation, and Metaheuristics in a complete, consistent, and centralized manner \cite{Brownlee2010}
% overview 
The standardized description of algorithms in the project requires an example implementation of each technique in a tutorial and potentially a code listing format \cite{Brownlee2010a}.
% why an example
A practical example is required for each algorithm description to show how the abstract procedures can be implemented as a concrete and executable computation.
% report
This report addresses the problem of which language to use for describing algorithm implementation examples, and recommends a specific language to be used.

% breakdown
Section~\ref{sec:language_selection} considers the problem of language selection focusing on the types of languages that could be used and examples, as well as a consideration of attributes that might be important when selecting a language.
Section~\ref{sec:methodology} proposes a methodology for evaluating and comparing languages for use in implementation examples for the standardized algorithm description, specifying an algorithm to use in the comparison, a set of languages to be considered, and the specific properties that will be measured and compared.
Four languages are considered: Python in Section~\ref{sec:python}, Perl in Section~\ref{sec:perl}, Ruby in Section~\ref{sec:ruby} and Lua in Section~\ref{sec:lua}.
The results of the comparison are reviewed in Section~\ref{sec:analysis} highlighting areas for improvement in the language selection methodology and in the execution of the comparison. 
Finally, the findings are discussed in Section~\ref{sec:findings} and the XXXXXXXX Programming Language is selected for use in the Clever Algorithms project.

% 
% Language Selection
% 
\section{Language Selection}
\label{sec:language_selection}
This section considers the importance of the programming language used in implementation examples in general, and looks at some languages and the attributes of programming languages that may be relevant.

% 
% Languages
%
\subsection{Languages}
% overview
Programming languages provide a means for a human to specify a computation, procedure, or application in a form and structure that can be understood and executed by a computer.
% scope
A introduction to programming languages is beyond the scope of this report, rather this section provides a brief overview of some programming language features, nomenclature and taxonomy suitable to make general comparisons between popular programming languages.

An important concern of programming language is the organizational paradigm that includes the methodology, abstractions, style, and structures. Some common examples include:

\begin{itemize}
	\item \emph{Logical}: Involves the use of mathematical logic (such as propositional or predicate logic) for computer programming. Programs are comprised of declarative logical statements or proposition that may be used to describe a rule-based reasoning or knowledge representation system. Some examples include Prolog. 
	\item \emph{Functional}: Focuses on the execution of mathematical functions (from lambda calculus) and avoid state and mutable data. The difference between a mathematical function and an imperative function is that the latter may have side effects (modify state beyond the scope of the function), where as the former may not. Some examples include LISP, Scheme, Erlang, and Haskell.	
	\item \emph{Procedural}: Also referred to as imperative programming that is concerned with organizing code into procedures (also called subroutines or functions). Procedures are defined in terms of a series expressions, some of which may in themselves be calls to procedures. Some common examples include: Pascal and C.
	\item \emph{Object-Oriented}: Models problems using objects that are comprised of data and procedures (also called methods) and may have an abstract definition (a class) and may be instantiated within a program. Objects can interact with each other by passing messages between the objects, such as one object invoking a method on another object. Some examples include C++, Java and C\#.
	\item \emph{Other}: There are many programming language paradigms not listed here, not limited to reflective, declarative, agent-oriented, aspect-oriented, event-driven, and meta programming. Most modern programming languages are not constrained to a single programming paradigm (called multi-paradigm), such as Java (imperative, object-oriented, generic, reflective) and Ruby (imperative, object-oriented, aspect-oriented, reflective, functional).
\end{itemize}

% compiled versus interprted
Another consideration of a programming language is implementation and whether or not it is compiled or interpreted (dynamic). 
% compiled
Compiled languages are those which employ a compiler to transform a higher-level language to a lower-level language. The compilation process can introduce various forms of static structure and type checking that may improve the quality of software produced, although the added steps between source code and execution may affect the speed and momentum of development. Some examples of compiled languages include C and C++ that compile to machine code, and Java and C\# that compile to bytecode and intermediate language respectively (incidentally, the latter two examples represent compilation to an intermediate language that is interpreted by a virtual machine).

% dynamic
Dynamic languages are high-level languages that are instead execute at runtime rather than requiring compilation to machine code before execution. They can be more productive for small specific tasks given the typically high-levels of abstraction and language features provided (such as dynamic typing and meta programming), although they can be relatively slower during exception compared to equivalent complied languages\footnote{Just-in-time compilation can improve the dynamic runtime of a program by compiling to a native format at runtime, and is offered by some dynamic and interpreted languages.}.

% types
An additional aspects of a computer programming languages that may be relevant include types, and whether the language is typed or untyped, and if typed whether the typing is static or dynamic.

% 
% Languages Attributes
%
\subsection{Languages Attributes}
% overview of problem
The programming language attributes that are important for describing algorithms in a book or website medium are different from those concerns for selecting a language for implementing an application, although there is some overlap.
% traditional properites
Traditional language selection concerns such as \emph{Static or Dynamically Typed}, \emph{Compiled or Interpreted}, and \emph{Single or Multi-paradigms} may be resolved by higher-level concerns such as popularity and commonality in the field and appropriateness in the industry or by communication concerns such as compactness and readability.

% practioner questions
\subsubsection{Practitioner}
The practitioner is concerned with the usability of the example, either directly in a language that can be exploited in a current project, or indirectly in a language or format that can easily be adapted for a current project.
% examples
Practitioners are most likely using the common languages in the industry for scientific and application computer programming, such as C, C++, C\#, Java, and potentially dynamic languages such as Python and Ruby. Paradigms used by practitioners are mostly likely Object-Oriented programming (OO), and Procedural programming only because it is subsumed by OO.
% questions
The following questions motivate language selection from the perspective of the practitioner:

\begin{itemize}
	\item What languages are most commonly used by practitioners in industry and/or academia?
	\item What language paradigms are most commonly used in algorithm implementations?
	\item Which languages provide the most appropriate functionalities in their standard library (such as random number generation, vector manipulation, etc.)?
\end{itemize}

% communication questions
\subsubsection{Communication}
The communication perspective on implementation examples is concerned with less practical concerns than usability, such as understandably, readability, and accessibility. 
% examples
Given a varied readership of amateurs, scientists, and developers, procedural programming examples would be the most easy to understand (modules of steps of expressions) and potentially object-oriented programming. System programming languages (such as C) are likely to be concise, although scripting programming languages such as Lua, Ruby, and Python are likely to provide compact source code listings.
% questions
The following questions motivate language selection from the perspective of implementation communication:

\begin{itemize}
	\item Given the varied background of the readership, is the average reader likely to easily understand the example?
	\item How large (number of printed lines or pages) is an an average implementation example take up?
	\item How readable (perhaps aesthetics such as balanced composition) is a given implementation example?	
\end{itemize}

% 
% Methodology
%
\section{Methodology}
\label{sec:methodology}
This section presents a methodology for comparing programming languages for presenting optimization (and similar) heuristic methods from the fields of Computational Intelligence, Natural Computation, and Metaheuristics in a book and/or website medium. The methodology is empirical, requiring a selection of a representative algorithm, the selection of some candidate programming languages for the selected algorithm to be programmed in, and the identification of some measures that may be collected from each implementation such that they can be compared.

% 
%  Algorithm
% 
\subsection{Algorithm}
The algorithm used for comparison must be representative of the algorithms that require implementation examples. A first-draft of all algorithms to be described in the Clever Algorithms project has been defined \cite{Brownlee2010a}. In that definition, popularity of each technique was measured against popular search engines. Algorithm popularity provides a reasonable basis for representation. The top five popular algorithms were: genetic algorithm, simulated annealing, random search, genetic programming, and tabu search.

The genetic algorithm provides a suitable representative algorithm in that it is not only popular, but also involves a number of non-trivial operators (compared to random or tabu search), although is relatively compact (compared to genetic programming that involves management of tree structures). Simulated annealing also provides a suitable representative algorithm, and may be used in followup and/or confirmatory studies. 

Algorithm~\ref{alg:genetic_algorithm} provides an abstract representation of a standardized genetic algorithm in pseudo code.

\begin{algorithm}[ht]
  \SetLine  
  
  \SetKwData{Pop}{Population}
  \SetKwData{Length}{numBits}
  \SetKwData{PopSize}{popSize}
  \SetKwData{BoutSize}{boutSize}
  \SetKwFunction{StopCondition}{StopCondition}
  \SetKwFunction{Mutate}{Mutate}
  \SetKwFunction{Fitness}{Fitness}
  \SetKwFunction{TournamentSelection}{TournamentSelection}
  \SetKwFunction{Crossover}{Crossover}
  \SetKwFunction{Replace}{Replace}
  \SetKwFunction{InitializeRandomBitstrings}{InitializeRandomBitstrings}  
  
  \KwIn{\PopSize, \Length, $p_{crossover}$, $p_{mutation}$}		
  \KwOut{\Pop}
  	
	\Pop $\leftarrow$ \InitializeRandomBitstrings{\PopSize, \Length}\;
	
	\While{$\neg$\StopCondition{}}
	{
	 \ForEach{$p_i \in$ \Pop}
	 {
	 	\Fitness{$p_i$}\;
	 }
	 $Population_{children} \leftarrow$ 0\;
	 \While{$Population_{children}$.size()$\neq$\PopSize}
	{
		$parent_1 \leftarrow$ \TournamentSelection{\Pop, \BoutSize}\;
		$parent_2 \leftarrow$ \TournamentSelection{\Pop, \BoutSize}\;
		$child_1$, $child_2 \leftarrow$ \Crossover{$p_2$, $p_2$, $p_{crossover}$}\;
		$Population_{children} \leftarrow child_1$\;
		$Population_{children} \leftarrow child_2$\;
	}
	 \ForEach{$p_i \in Population_{children}$}
	 {
    	\Mutate{$p_i$, $p_{mutation}$}\;
	 }	 
	 \Replace{\Pop, $Population_{children}$}\;
	}
	\Return{\Pop}\;
	
	\caption{Pseudo Code for the Genetic Algorithm.}
	\label{alg:genetic_algorithm}
\end{algorithm}


% 
% Implementations
% 
\subsection{Implementations}
% overview
Implementing an algorithm in a range of different programming languages is time consuming. Heuristics are required to reduce the set of possible languages down to a manageable number that can be compared.
% strategy
This section considers algorithm popularity as a heuristic in a similar manner to the way in which algorithms were selected for description in the Clever Algorithms project. A listing of common and popular languages was prepared and a script written to measure the number of search results for each language across a range of search domains: Google web, book, and scholar. This process was then repeated for the language name in conjunction with the phrase `optimization' to assess the specific use of the language (Section~\ref{subsubsec:popularity}). The requirements for a selected language are described based on generalizations from language classes (from Section~\ref{sec:language_selection}) and from the needs of the readership (Section~\ref{subsubsec:requirements}). Finally, a subset of popular algorithms were selected for comparison (Section~\ref{subsubsec:selection}).

% 
% Language Popularity
% 
\subsubsection{Language Popularity}
\label{subsubsec:popularity}
This section lists the results of measuring the popularity of 24 popular programming languages. 
% collection 
The measures were taken from the Google web, book, and scholar search services on January 20th 2010 for the phrase `\emph{``NAME programming language'' AND ``genetic algorithm''}' (where `NAME' is replaced with each specific language name). The results are listed in Table~\ref{tab:results} that shows algorithm name, a raw approximation of the number of results from each service and the score as the sum of the normalized approximate measures. Results are ordered by score, descending.

\begin{table}[ht]
	\centering
		\begin{tabularx}{\textwidth}{lXXXX}
		\toprule
		\textbf{Language} & \textbf{Google Web} & \textbf{Google Book} & \textbf{Google Scholar} & \textbf{Score} \\ 
		\toprule
		c & 940 & 91 & 801 & 3.0 \\
		java & 735 & 39 & 553 & 1.899 \\
		c++ & 673 & 42 & 9 & 1.187 \\
		lisp & 163 & 51 & 139 & 0.902 \\
		matlab & 166 & 24 & 138 & 0.607 \\
		python & 238 & 7 & 88 & 0.435 \\
		erlang & 375 & 0 & 0 & 0.395 \\
		pascal & 182 & 11 & 30 & 0.347 \\
		ada & 161 & 10 & 16 & 0.296 \\
		fortran & 62 & 9 & 39 & 0.208 \\
		scheme & 105 & 3 & 13 & 0.155 \\
		perl & 100 & 1 & 35 & 0.155 \\
		c\# & 91 & 1 & 30 & 0.139 \\
		ruby & 108 & 1 & 4 & 0.125 \\
		visual basic & 35 & 3 & 46 & 0.121 \\
		lua & 59 & 0 & 1 & 0.058 \\
		scala & 31 & 0 & 1 & 0.028 \\
		php & 21 & 0 & 7 & 0.025 \\
		ocaml & 27 & 0 & 2 & 0.025 \\
		objective-c & 14 & 1 & 2 & 0.022 \\
		mathematica & 6 & 1 & 4 & 0.016 \\
		smalltalk & 13 & 0 & 6 & 0.015 \\
		haskell & 12 & 0 & 1 & 0.008 \\
		javascript & 6 & 0 & 0 & 0.0 \\
		\bottomrule
		\end{tabularx}	
	\caption{Algorithm programming language listing measures.}
	\label{tab:results}
\end{table}

% 
% Language Requirements
% 
\subsubsection{Language Requirements}
\label{subsubsec:requirements}
This section lists the requirements for selecting a language.

\begin{itemize}
	\item \emph{The language shall allow programming in the procedural paradigm.} A procedural representation is expected to provide the most transferrable instantiation of an algorithm. Many languages support the procedural paradigm and procedural code examples can be easily ported to popular paradigms such as object-oriented and functional.
	\item \emph{The language shall be interpreted.} The compilation of a program is an additional step to the reader in executing a provided code example. In some languages this step is minimal, in others it may require an understanding of the intermediate process and linking. An interpreted program can be executed by an interpret in a single step, useful for modification and tweaking by the reader.
	\item \emph{The language shall be available and accessible at no monetary cost.} Some languages require a proprietary framework or application to compile or interpret the source code (such as .NET), some of which must be purchased (such as Mathematica and Matlab). There may be exceptions and open source equivalents, although the main distribution for the language shall require no monetary cost to acquire and use.
\end{itemize}

% 
% Selected Languages
% 
\subsubsection{Selected Languages}
\label{subsubsec:selection}
The following are the languages selected for comparison based on the popularity heuristics and the language selection requirements:
\begin{enumerate}
	\item The Python Programming Language
	\item The Perl Programming Language
	\item The Ruby Programming Language
	\item The Lua Programming Language
\end{enumerate}

% overview
The selected languages are listed in order of popularity from Table~\ref{tab:results}. The languages are interpreted (dynamic),  available at no cost, and support the procedural programming paradigm. The Lua programming language is technically compiled, although the compilation process occurs at execution time and therefor remains a functionally an interpreted language.
% guideliens
The following specifics guidelines for the algorithm implementations across the four languages. 
\begin{itemize}
	\item Procedural (imperative) programming paradigm (functions and data structures, no objects).
	\item Promote readability over fancy language tricks (such as Regex and obscure one-liners).
	\item Strive toward $<80$ characters per line (code listings wrap automatically at whitespace break points).
	\item Use the same general procedures (algorithm decomposition) across language implementations, for consistency.
	\item Target $<100$ lines per implementation example.
	\item Avoid the use of magic numbers, prefer the use of constants.
	\item Avoid compressing flow control structures to one or fewer lines (if-else,while,for).
	\item No comments in implementations.
\end{itemize}

The algorithm implements across the languages should use the same number of procedures with the same functionality, and the the same constants. The algorithm shall use a bit-string (string data type) implementation, one-point crossover, point mutation, tournament selection and be applied to a 64-bit instance of the One-Max problem. 

% 
% Python
% 
\section{Python}
\label{sec:python}
Algorithm Listing~\ref{pythonga} provides an example of the Genetic Algorithm implemented in the Python Programming Language. Tested against the Python interpreter version 2.6.1.
\lstinputlisting[firstline=7,language=python,caption=Genetic Algorithm in the Python Programming Language, label=pythonga]{../../src/language_comparison/genetic_algorithm.py}

% 
% Perl
% 
\section{Perl}
\label{sec:perl}
Algorithm Listing~\ref{perlga} provides an example of the Genetic Algorithm implemented in the Perl Programming Language. Tested against the Perl interpreter version 5.10.0.
\lstinputlisting[firstline=7,language=perl,caption=Genetic Algorithm in the Perl Programming Language, label=perlga]{../../src/language_comparison/genetic_algorithm.pl}

% 
% Ruby
% 
\section{Ruby}
\label{sec:ruby}
Algorithm Listing~\ref{rubyga} provides an example of the Genetic Algorithm implemented in the Ruby Programming Language. Tested against the ruby interpreter version 1.8.7 and 1.9.1.
\lstinputlisting[firstline=7,language=ruby,caption=Genetic Algorithm in the Ruby Programming Language, label=rubyga]{../../src/language_comparison/genetic_algorithm.rb}

% 
% Lua
% 
\section{Lua}
\label{sec:lua}
Algorithm Listing~\ref{luaga} provides an example of the Genetic Algorithm implemented in the Lua Programming Language. Tested against the Lua interpreter version 5.1.4.
\lstinputlisting[firstline=7,language=lua,caption=Genetic Algorithm in the Lua Programming Language, label=luaga]{../../src/language_comparison/genetic_algorithm.lua}

% 
% Results
% 
\section{Results}
\label{sec:results}
% overview
Three measures were collected over the for algorithm-language implementations, including: \emph{Total lines} that assess the absolute readable length of an example, \emph{Total Chars} that provides some information about the expressiveness of the language, and \emph{Avg Cars/Line} that provides an indication of the density of the example. Smaller numbers are better for all three measures, although the guidelines from section \ref{subsubsec:selection} apply.
% results
The results are provided in Table~\ref{tab:implementation_results} and show the basic analytics of the source files for each of the four algorithm implementations.

\begin{table}[ht]
	\centering
		\begin{tabularx}{\textwidth}{lXXX}
		\toprule
		\textbf{Algorithm} & \textbf{Total Lines} & \textbf{Total Chars} & \textbf{Avg Chars/Line} \\ 
		\toprule
		Python & 79 & 1959 & 25 \\
		Perl & 87 & 2130 & 24 \\		
		Ruby & 72 & 1764 & 25 \\
		Lua & 101 & 2202 & 22 \\
		\bottomrule
		\end{tabularx}	
	\caption{Algorithm programming language listing measures.}
	\label{tab:implementation_results}
\end{table}

% 
% Analysis
% 
\section{Analysis}
\label{sec:analysis}
This section analyses both the methodology and the results of the language comparison.

% 
% Methodology
% 
\subsection{Methodology}
this is a hard problem
consider compiled languages

% 
% Implementation
% 
\subsection{Implementation}
hard to implement similar procedures across languages

basic bias because of the authors experience
guidelines for implementation can be used during the writing of the book

there are still one liners in there, some perl is as unreadable as some ruby

% 
% Findings
% 
\section{Findings}
\label{sec:findings}
% report
todo
% findings

% future


% bibliography
\bibliographystyle{plain}
\bibliography{../bibtex}

\end{document}
% EOF