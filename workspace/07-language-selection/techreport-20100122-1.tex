% Programming Language Selection for Introducing Unconventional Optimization Algorithms

% The Clever Algorithms Project: http://www.CleverAlgorithms.com
% (c) Copyright 2010 Jason Brownlee. Some Rights Reserved. 
% This work is licensed under a Creative Commons Attribution-Noncommercial-Share Alike 2.5 Australia License.

\documentclass[a4paper, 11pt]{article}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{url}
\usepackage[pdftex,breaklinks=true,colorlinks=true,urlcolor=blue,linkcolor=blue,citecolor=blue,]{hyperref}
\usepackage{geometry}
\geometry{verbose,a4paper,tmargin=25mm,bmargin=25mm,lmargin=25mm,rmargin=25mm}

% Dear template user: fill these in
\newcommand{\myreporttitle}{Programming Language Selection for Optimization Algorithms}
% \newcommand{\myreportsubtitle}{}
\newcommand{\myreportauthor}{Jason Brownlee}
\newcommand{\myreportemail}{jasonb@CleverAlgorithms.com}
\newcommand{\myreportproject}{The Clever Algorithms Project\\\url{http://www.CleverAlgorithms.com}}
\newcommand{\myreportdate}{20100122}
\newcommand{\myreportfulldate}{January 22, 2010}
\newcommand{\myreportversion}{1}
\newcommand{\myreportlicense}{\copyright\ Copyright 2010 Jason Brownlee. Some Rights Reserved. This work is licensed under a Creative Commons Attribution-Noncommercial-Share Alike 2.5 Australia License.}

% leave this alone, it's templated baby!
% \title{{\myreporttitle}: {\myreportsubtitle}\footnote{\myreportlicense}}
\title{{\myreporttitle}\footnote{\myreportlicense}}
\author{\myreportauthor\\{\myreportemail}\\\small\myreportproject}
\date{\myreportfulldate\\{\small{Technical Report: CA-TR-{\myreportdate}-\myreportversion}}}
\begin{document}
\maketitle

% write a summary sentence for each major section
\section*{Abstract} 
todo

\begin{description}
	\item[Keywords:] {\small\texttt{Clever, Algorithms, Language, Selection, Optimization}}
\end{description} 

% summarise the document breakdown with cross references
\section{Introduction}
\label{sec:introduction}
% project
The Clever Algorithms project aims to describe a large number of optimization algorithms from the fields of Computational Intelligence, Natural Computation, and Metaheuristics in a complete, consistent, and centralized manner \cite{Brownlee2010}
% overview 
The standardized description of algorithms in the project requires an example implementation of each technique in a tutorial and potentially a code listing format \cite{Brownlee2010a}.
% why an example
A practical example is required for each algorithm description to show how the abstract procedures can be implemented as a concrete and executable computation.
% report
This report addresses the problem of which language to use for describing algorithm implementation examples, and recommends a specific language to be used.

% breakdown
Section~\ref{sec:language_selection} considers the problem of language selection focusing on the types of languages that could be used and examples, as well as a consideration of attributes that might be important when selecting a language.
Section~\ref{sec:methodology} proposes a methodology for evaluating and comparing languages for use in implementation examples for the standardized algorithm description, specifying an algorithm to use in the comparison, a set of languages to be considered, and the specific properties that will be measured and compared.
Four languages are considered: Javascript in Section~\ref{sec:javascript}, Lua in Section~\ref{sec:lua}, Python in Section~\ref{sec:python} and Ruby in Section~\ref{sec:ruby}.
The results of the comparison are reviewed in Section~\ref{sec:analysis} highlighting areas for improvement in the language selection methodology and in the execution of the comparison. 
Finally, the findings are discussed in Section~\ref{sec:findings} and the Ruby Programming Language is selected for use in the Clever Algorithms project.

% 
% Language Selection
% 
\section{Language Selection}
\label{sec:language_selection}
This section considers the importance of the programming language used in implementation examples in general, and looks at some languages and the attributes of programming languages that may be relevant.

% 
% Languages
%
\subsection{Languages}
% overview
Programming languages provide a means for a human to specify a computation, procedure, or application in a form and structure that can be understood and executed by a computer.
% scope
A introduction to programming languages is beyond the scope of this report, rather this section provides a brief overview of some programming language features, nomenclature and taxonomy suitable to make general comparisons between popular programming languages.

An important concern of programming language is the organizational paradigm that includes the methodology, abstractions, style, and structures. Some common examples include:

\begin{itemize}
	\item \emph{Logical}: Involves the use of mathematical logic (such as propositional or predicate logic) for computer programming. Programs are comprised of declarative logical statements or proposition that may be used to describe a rule-based reasoning or knowledge representation system. Some examples include Prolog. 
	\item \emph{Functional}: Focuses on the execution of mathematical functions (from lambda calculus) and avoid state and mutable data. The difference between a mathematical function and an imperative function is that the latter may have side effects (modify state beyond the scope of the function), where as the former may not. Some examples include LISP, Scheme, Erlang, and Haskell.	
	\item \emph{Procedural}: Also referred to as imperative programming that is concerned with organizing code into procedures (also called subroutines or functions). Procedures are defined in terms of a series expressions, some of which may in themselves be calls to procedures. Some common examples include: Pascal and C.
	\item \emph{Object-Oriented}: Models problems using objects that are comprised of data and procedures (also called methods) and may have an abstract definition (a class) and may be instantiated within a program. Objects can interact with each other by passing messages between the objects, such as one object invoking a method on another object. Some examples include C++, Java and C\#.
	\item \emph{Other}: There are many programming language paradigms not listed here, not limited to reflective, declarative, agent-oriented, aspect-oriented, event-driven, and meta programming. Most modern programming languages are not constrained to a single programming paradigm (called multi-paradigm), such as Java (imperative, object-oriented, generic, reflective) and Ruby (imperative, object-oriented, aspect-oriented, reflective, functional).
\end{itemize}

% compiled versus interprted
Another consideration of a programming language is implementation and whether or not it is compiled or interpreted (dynamic). 
% compiled
Compiled languages are those which employ a compiler to transform a higher-level language to a lower-level language. The compilation process can introduce various forms of static structure and type checking that may improve the quality of software produced, although the added steps between source code and execution may affect the speed and momentum of development. Some examples of compiled languages include C and C++ that compile to machine code, and Java and C\# that compile to bytecode and intermediate language respectively (incidentally, the latter two examples represent compilation to an intermediate language that is interpreted by a virtual machine).

% dynamic
Dynamic languages are high-level languages that are instead execute at runtime rather than requiring compilation to machine code before execution. They can be more productive for small specific tasks given the typically high-levels of abstraction and language features provided (such as dynamic typing and meta programming), although they can be relatively slower during exception compared to equivalent complied languages\footnote{Just-in-time compilation can improve the dynamic runtime of a program by compiling to a native format at runtime, and is offered by some dynamic and interpreted languages.}.

% types
An additional aspects of a computer programming languages that may be relevant include types, and whether the language is typed or untyped, and if typed whether the typing is static or dynamic.

% 
% Languages Attributes
%
\subsection{Languages Attributes}
% overview of problem
The programming language attributes that are important for describing algorithms in a book or website medium are different from those concerns for selecting a language for implementing an application, although there is some overlap.
% traditional properites
Traditional language selection concerns such as \emph{Static or Dynamically Typed}, \emph{Compiled or Interpreted}, and \emph{Single or Multi-paradigms} may be resolved by higher-level concerns such as popularity and commonality in the field and appropriateness in the industry or by communication concerns such as compactness and readability.

% practioner questions
\subsubsection{Practitioner}
The practitioner is concerned with the usability of the example, either directly in a language that can be exploited in a current project, or indirectly in a language or format that can easily be adapted for a current project.
% examples
Practitioners are most likely using the common languages in the industry for scientific and application computer programming, such as C, C++, C\#, Java, and potentially dynamic languages such as Python and Ruby. Paradigms used by practitioners are mostly likely Object-Oriented programming (OO), and Procedural programming only because it is subsumed by OO.
% questions
The following questions motivate language selection from the perspective of the practitioner:

\begin{itemize}
	\item What languages are most commonly used by practitioners in industry and/or academia?
	\item What language paradigms are most commonly used in algorithm implementations?
	\item Which languages provide the most appropriate functionalities in their standard library (such as random number generation, vector manipulation, etc.)?
\end{itemize}

% communication questions
\subsubsection{Communication}
The communication perspective on implementation examples is concerned with less practical concerns than usability, such as understandably, readability, and accessibility. 
% examples
Given a varied readership of amateurs, scientists, and developers, procedural programming examples would be the most easy to understand (modules of steps of expressions) and potentially object-oriented programming. System programming languages (such as C) are likely to be concise, although scripting programming languages such as Lua, Ruby, and Python are likely to provide compact source code listings.
% questions
The following questions motivate language selection from the perspective of implementation communication:

\begin{itemize}
	\item Given the varied background of the readership, is the average reader likely to easily understand the example?
	\item How large (number of printed lines or pages) is an an average implementation example take up?
	\item How readable (perhaps aesthetics such as balanced composition) is a given implementation example?	
\end{itemize}

% 
% Methodology
%
\section{Methodology}
\label{sec:methodology}
This section presents a methodology for comparing programming languages for presenting optimization (and similar) heuristic methods from the fields of Computational Intelligence, Natural Computation, and Metaheuristics in a book and/or website medium. The methodology is empirical, requiring a selection of a representative algorithm, the selection of some candidate programming languages for the selected algorithm to be programmed in, and the identification of some measures that may be collected from each implementation such that they can be compared.

% 
%  Algorithm
% 
\subsection{Algorithm}
The algorithm used for comparison must be representative of the algorithms that require implementation examples. A first-draft of all algorithms to be described in the Clever Algorithms project has been defined \cite{Brownlee2010a}. In that definition, popularity of each technique was measured against popular search engines. Algorithm popularity provides a reasonable basis for representation. The top five popular algorithms were: genetic algorithm, simulated annealing, random search, genetic programming, and tabu search.

The genetic algorithm provides a suitable representative algorithm in that it is not only popular, but also involves a number of non-trivial operators (compared to random or tabu search), although is relatively compact (compared to genetic programming that involves management of tree structures). Simulated annealing also provides a suitable representative algorithm, and may be used in followup and/or confirmatory studies. 

The following algorithm listing provides an abstract representation of a standardized genetic algorithm in pseudo code.

TODO.


% 
% Implementations
% 
\subsection{Implementations}
procedural, 4 dynamic languages
js, lua, python, and ruby


language selection? google search results as a rough popularity measure?
top 4 languages?

consider google searches for ``language name'' + ``optimization'' across google web, books, and scholar


% 
% Comparison
% 
\subsection{Comparison}
compare on conciseness, compactness, communication qualities - accessibility, etc. readability

rank or score on a set of properties, subjective, but a starting point

The measures to be collected for each implementation are as follows:

\begin{table}[ht]
	\centering
		\begin{tabularx}{\textwidth}{lX}
		\toprule
		\textbf{Measure} & \textbf{Description} \\ 
		\toprule
		LOC & The number of lines of code in the listing \\
		\bottomrule
		\end{tabularx}	
	\caption{Algorithm programming language listing measures.}
	\label{tab:measures}
\end{table}


% 
% Javascript
% 
\section{Javascript}
\label{sec:javascript}
todo


% 
% Lua
% 
\section{Lua}
\label{sec:lua}
todo


% 
% Python
% 
\section{Python}
\label{sec:python}
todo


% 
% Ruby
% 
\section{Ruby}
\label{sec:ruby}
todo


% 
% Analysis
% 
\section{Analysis}
\label{sec:analysis}

how could the methodology be improved?
how could the execution be improved?


% 
% Findings
% 
\section{Findings}
\label{sec:findings}
% report

% findings

% future


% bibliography
\bibliographystyle{plain}
\bibliography{../bibtex}

\end{document}
% EOF